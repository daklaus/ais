//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2015 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct struct__IO_FILE {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct struct__IO_marker * e12;
    struct struct__IO_FILE * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct struct__IO_marker {
    struct struct__IO_marker * e0;
    struct struct__IO_FILE * e1;
    int32_t e2;
};

// ------------------- Function Prototypes --------------------

int32_t check_serial(char * username, char * serial);
int32_t handle_checks(void);

// --------------------- Global Variables ---------------------

int32_t handle = 0x8048479; // 0x8049b08
int32_t g2 = 0; // 0x8049b14
int32_t g3 = 0; // 0x8049b18

// ------------------------ Functions -------------------------

// Address range: 0x8048479 - 0x80484c7
int32_t handle_checks(void) {
    int32_t v1;
    memcpy((char *)&v1, (char *)0x80488f8, 41);
    // branch -> 0x804849a
    int32_t fputc_rc; // 0x80484b2
    for (int32_t i = 0; i < 39; i += 2) {
        // 0x804849a
        int32_t v2;
        char c = *(char *)(i - 53 + (int32_t)&v2); // 0x80484a3
        fputc_rc = fputc((int32_t)c, (struct struct__IO_FILE *)g2);
        // continue -> 0x804849a
    }
    // 0x80484c1
    return fputc_rc;
}

// Address range: 0x80484c8 - 0x80485f3
int32_t check_serial(char * username, char * serial) {
    int32_t v1;
    int32_t int_pointer = &v1; // 0x80484c9_0
    int32_t serial2 = (int32_t)serial; // 0x80484cf
    int32_t handle_xor = (int32_t)*(char *)(serial2 + 9) ^ (int32_t)handle_checks; // 0x80484e0
    handle = handle_xor;
    int32_t i = 1;
    // branch -> 0x80484ff
    while (true) {
        unsigned char curr_user_char = *(char *)(i + (int32_t)username); // 0x8048508
        unsigned char v7 = *(char *)(int_pointer - 24 + i); // 0x8048512
        uint32_t v8 = (int32_t)v7 + (int32_t)curr_user_char; // 0x804851a
        char v9 = *(char *)(v8 + 0x8049ac0 + (v8 / 71 | 8)); // 0x804854c
        *(char *)(int_pointer - 23 + i) = v9;
        int32_t i = i + 1; // 0x8048557
        if (i >= 9) {
            // 0x8048560
            unsigned char v11;
            uint32_t v12 = -1 - (int32_t)v11; // 0x8048567
            int32_t v13 = (int32_t)*(char *)(v12 + 0x8049ac0 + -7 * v12 / 71); // 0x8048598
            int32_t j = 0;
            // branch -> 0x80485ab
            while (true) {
                char v15 = *(char *)(int_pointer - 23 + j); // 0x80485ae
                int32_t v16 = j + 1; // 0x80485c9
                if (v15 == *(char *)(j + serial2)) {
                    // 0x80485cc
                    if (v16 >= 10) {
                        // break -> 0x80485d2
                        break;
                    }
                    j = v16;
                    // continue -> 0x80485ab
                    continue;
                }
                // 0x80485eb
                return 0;
            }
            // 0x80485d2
            handle = v13 ^ handle_xor;
            // branch -> 0x80485eb
            // 0x80485eb
            return 1;
        }
        // 0x80484ff
//        i = i2;
        // branch -> 0x80484ff
    }
}

// Address range: 0x804864c - 0x80487ef
int main(int argc, char ** argv) {
    int32_t v1 = 0x65757153; // bp-32
    int32_t v2;
    if ((struct struct__IO_FILE *)argc != (struct struct__IO_FILE *)3) {
        // 0x8048690
        v2 = *(int32_t *)argv;
        fprintf((struct struct__IO_FILE *)g3, "useage: %s <user> <serial>\n", &v2);
        // branch -> 0x80487dd
        // 0x80487dd
        return -1;
    }
    char str = 0;
    int32_t v3 = (int32_t)argv; // 0x80486db_1
    v2 = 10;
    strncpy(&str, (char *)*(int32_t *)(v3 + 4), 10);
    int32_t str2 = 0;
    int32_t str3 = *(int32_t *)(v3 + 8); // 0x804871d
    v2 = 10;
    strncpy((char *)&str2, (char *)str3, 10);
    if (str == 0) {
        // 0x8048740
        v2 = 16;
        fwrite("Empty User Name\n", 1, 16, (struct struct__IO_FILE *)g3);
        // branch -> 0x80487dd
        // 0x80487dd
        return -1;
    }
    // 0x804876e
    int32_t result; // 0x80487dd1
    if (check_serial(&str, (char *)&str2) == 0) {
        // 0x8048784
        v2 = 22;
        fwrite("Invalid Serial Number\n", 1, 22, (struct struct__IO_FILE *)g3);
        result = -1;
        // branch -> 0x80487dd
    } else {
        // 0x80487b2
        handle_checks();
        fprintf((struct struct__IO_FILE *)g2, "%s\n", &v1);
        result = 0;
        // branch -> 0x80487dd
    }
    // 0x80487dd
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int fprintf(FILE *restrict, const char *restrict, ...);
// int fputc(int, FILE *);
// size_t fwrite(const void *restrict, size_t, size_t, FILE *restrict);
// char * strncpy(char *restrict, const char *restrict, size_t);

// --------------- Instruction-Idiom Functions ----------------

// char * memcpy(char * a1, char * a2, int32_t a3);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.1.2)
// Detected language: C
// Detected functions: 3
// Decompiler release: v2.1.1 (2015-11-11)
// Decompilation date: 2015-11-12 03:38:16
